{
    "info": {
        "name": "English (US)",
        "version": "0.1",
        "authors": ["Blyfh"]
    },
    "error": {
        "PythonVer":            ("Error",         "Your version of Python is not supported. Please use Python {min_ver} or higher."),

        "NeverStopped":         ("SyntaxError",   "Program was never stopped with command 'STP'."),
        "MaxPrgLength":         ("StopExecution", "Maximum program length exceeded. Can only have up to {max_adrs} memory cells, not {adrs}."),
        "AdrsNotChronological": ("SyntaxError",   "Address {small_adr} appears after address {big_adr} even though memory cells have to be in chronological order."),
        "AdrNotUnique":         ("SyntaxError",   "Address {adr} appears more than once even though it has to be unique."),
        "CmdHasValOpr":         ("SyntaxError",   "Only command 'LDA' supports '#<value>' format like '#{opr}'."),
        "UnknownOprTyp":        ("ValueError",    "Unknown operand type: '{opr}'. An operand has to be an address (format '<nonnegative int>' or '(<nonnegative int>)') or an absolute value (format '#<int>')."),
        "MaxIterationDepth":    ("MaxIteration",  "Maximum iteration depth exceeded. Can only jump up to {max_jmps} times to memory cell {adr}."),
        "ValNotNngInt_Load":    ("TypeError",     "Unable to load accumulator value in memory cell {adr}. Value must be a nonnegative integer, not '{val}'."),
        "CmdStpHasOpr":         ("SyntaxError",   "Command 'STP' does not take operands. Please remove operand in memory cell {adr}."),
        "MissingOpr":           ("SyntaxError",   "Command {cmd} in memory cell {adr} requires an operand but none was given."),
        "AdrTokNotInt":         ("TypeError",     "Expected an address, not '{tok}'. An address of a memory cell has to be a nonnegative integer."),
        "AdrTokIsNegative":     ("ValueError",    "Expected an address, not '{tok}'. An address of a memory cell has to be nonnegative."),
        "TokNotValOrCmd":       ("TypeError",     "Expected a command or a value in memory cell {adr}, not '{tok}'."),
        "MaxCelLength":         ("SyntaxError",   "Memory cell {adr} has too many tokens. A memory cell can only have up to 3 tokens (excluding comments): 1. address, 2. command/value, 3. operand"),
        "TokNotVal_Overwrite":  ("TypeError",     "Expected token {tpos} of memory cell {adr} to be a value, not '{tok}' while trying to overwrite it to {new_val}"),
        "TokNotCmd":            ("TypeError",     "Expected token {tpos} of memory cell {adr} to be a command, not '{tok}'."),
        "TokNotCmd_EmptyTok":   ("TypeError",     "Expected token {tpos} of memory cell {adr} to be a command, but it is empty."),
        "TokNotOpr":            ("TypeError",     "Expected token {tpos} of memory cell {adr} to be an operand, not '{tok}'."),
        "TokNotOpr_EmptyTok":   ("TypeError",     "Expected token {tpos} of memory cell {adr} to be an operand, but it is empty."),
        "TokNotAdr":            ("TypeError",     "Expected token {tpos} of memory cell {adr} to be an address, not '{tok}'."),
        "TokNotAdr_EmptyTok":   ("TypeError",     "Expected token {tpos} of memory cell {adr} to be an address, but it is empty."),
        "OprTokNotStr":         ("TypeError",     "Expected to receive a string, not '{opr_str}' while trying to get an operand."),
        "ValOprNotInt":         ("TypeError",     "Expected an operand in memory cell {adr}, not '{opr}'. Value after '#' has to be an integer."),
        "IndOprNotNngInt":      ("TypeError",     "Expected an operand in memory cell {adr}, not '{opr}'. Address nested into brackets has to be a nonnegative integer."),
        "IndOprIsNegative":     ("ValueError",    "Expected an operand in memory cell {adr}, not '{opr}'. Address nested into brackets has to be nonnegative."),
        "UnknownOperand":       ("TypeError",     "Expected an operand in memory cell {adr}, not '{opr}'. An operand has to be an address (format '<nonnegative int>' or '(<nonnegative int>)') or an absolute value (format '#<int>').")
    },
    "file": {
        "DocumentsDir":   "Documents",
        "AssemblerFiles": "Assembler files",
        "TextFiles":      "Text files",

        "UnsavedChanges": "Unsaved Changes",
        "Save?":          "Save program before exiting?",

        "OpenFile": "Open File",
        "SaveFile": "Save File"
    },
    "gui": {
        "title": "Assemblitor",
        "minsize": (637, 500),

        "File":     "File",
        "Open":     "Open",
        "Reload":   "Reload",
        "Save":     "Save",
        "SaveAs":   "Save As",
        "Settings": "Settings",
        "Exit":     "Exit",

        "Help":      "Help",
        "Assembly":  "Assembly",
        "Shortcuts": "Shortcuts",
        "DemoPrg":   "Demo Program",
        "About":     "About",

        "Run":      "Run",
        "StepMode": "Step-By-Step Mode",

        "PC:":  "Program Counter:",
        "ACC:": "Accumulator:",
        "IR:":  "Instruction Register:"
    },
    "set_win": {
        "title": "Settings"
    },
    "asm_win": {
        "title": "Assembly",
        "minsize": (710, 200),

        "text":  """This Assembly dialect is a very low-level column-oriented programming language that is close to machine code. It is not case sensitive.

It consists of a sequence of 'memory cells' that can store values or commands. Each memory cell starts with its address and ends with a line break. The memory cells have to be in increasing order but empty memory cells don't have to be displayed. A value has to be stored after the address as an integer. An empty memory cell will be interpreted as having a value of 0. A command is also stored after the address. There are many commands and some of them require operands to work.
Comments can be made with a semicolon. All text between the semicolon and the next line break will be ignored by the computer.

The program orients itself to the architecture of a Von-Neumann processor. This means it takes usage of the program counter (PC), the accumulator (ACC) and the instruction register (IR). The PC is set to 0 by default. If the program is executed, the command at the address stored in the PC will be loaded into the IR. There the command can be executed. After its execution the PC gets increased by one (excluding jumps and stops) and the next command can be loaded.


A simple program may look like this:
{    00 LDA 04 ; load the value of the 4th memory cell into the ACC
    01 STA 05 ; store the value of the ACC into the 5th memory cell
    02 STP    ; stop the program
    04 42     ; a stored value
}
This would be the result after executing the program:
{    00 LDA 04
    01 STA 05
    02 STP
    03        ; <--- Notice how the formerly hidden 3rd memory cell is now displayed
    04 42
    05 42
}

A list of all accepted commands:
    {STP    } - stops the program
    {LDA n  } - loads the value at memory cell n into the ACC
    {LDA #n } - loads the value n into the ACC
    {LDA (n)} - loads the value of the memory cell that has the address that is stored in memory cell n
    {STA n  } - stores the value of the ACC into memory cell n
    {ADD n  } - adds the value at memory cell n to the value of the ACC and stores the result into the ACC
    {SUB n  } - subtracts the value at memory cell n from the value of the ACC and stores the result into the ACC
    {MUL n  } - multiplies the value at memory cell n by the value of the ACC and stores the result into the ACC
    {JMP n  } - jumps to memory cell n by setting the PC to n
    {JZE n  } - jumps to memory cell n by setting the PC to n if the value of the ACC is equal to zero
    {JLE n  } - jumps to memory cell n by setting the PC to n if the value of the ACC is less or equal to zero"""
    },
    "shc_win": {
        "title":    "Shortcuts",
        "geometry": "272x110",

        "combos": """Ctrl + Enter
Shift + Enter
Ctrl + O
F5
Ctrl + S
Ctrl + Shift + S""",

        "actions": """Run program
Line break without new address
Open file
Reload file
Save file
Save file as"""
    },
    "abt_win": {
        "title":    "About",
        "geometry": "310x140",

        "text": """    A simple emulator and editor for Assembly
    Version: 0.1 Alpha
    Made by Blyfh in 2022

    Found a bug? Tell me on
    https://github.com/Blyfh/assemblitor/issues/new
        """
    },
    "demo": """; A simple countdown program
00 JMP 03
01 5
02 1
03 LDA 01
04 SUB 02
05 JLE 08
06 STA 01
07 JMP 04
08 STP"""
}